<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Salvation Breakers Helper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: rgb(20, 20, 20);
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        button {
            position: absolute;
            background-color: rgb(50, 50, 50);
            color: white;
            border: 2px solid rgb(180, 180, 180);
            padding: 10px;
            cursor: pointer;
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            font-size: 16px;
        }
        button:hover {
            background-color: rgb(180, 180, 180);
        }
        #importButton {
            left: 480px;
            top: 545px;
            width: 100px;
            height: 40px;
        }
        #exportButton {
            left: 600px;
            top: 545px;
            width: 100px;
            height: 40px;
        }
        .popup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 2px solid rgb(180, 180, 180);
            border-radius: 5px;
            font-size: 16px;
            bottom: 10px;
            right: 10px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <button id="importButton">Import</button>
    <button id="exportButton">Export</button>
    <script>
        // Version number
        const versionNumber = "v1.1";

        // Screen dimensions
        const SCREEN_WIDTH = 980;
        const SCREEN_HEIGHT = 650;

        // Grid settings
        const GRID_SIZE = 9;
        const CELL_SIZE = 50;
        const GRID_X = 300;
        const GRID_Y = 75;

        // Palette settings
        const PALETTE_WIDTH = 270;
        const PALETTE_HEIGHT = SCREEN_HEIGHT - 70;
        const PALETTE_X = 10;
        const PALETTE_Y = 10;
        const PALETTE_SCROLL_SPEED = 50;
        const PALETTE_BLOCK_SPACING = 10;

        // Count panel settings
        const COUNT_WIDTH = 200;
        const COUNT_HEIGHT = SCREEN_HEIGHT - 70;
        const COUNT_X = GRID_X + GRID_SIZE * CELL_SIZE + 20;
        const COUNT_Y = 10;
        const COUNT_TEXT_SPACING = 30;

        // Colors
        const DARK_BG = [20, 20, 20];
        const LIGHT_GRAY = [180, 180, 180];
        const DARK_GRAY = [50, 50, 50];
        const WHITE = [255, 255, 255];
        const BLACK = [0, 0, 0];
        const RED = [200, 0, 0];
        const PURPLE = [128, 0, 128];

        // Grid occupation (0: empty, 1: occupied)
        let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));

        // Block class
        class Block {
            constructor(shape, color, pos, name, anchorCells, isPalette = false) {
                this.shape = shape;
                this.color = color;
                this.pos = [...pos];
                this.prevPos = [...pos];
                this.placed = false;
                this.dragging = false;
                this.offset = [0, 0];
                this.isPalette = isPalette;
                this.name = name;
                this.anchorCells = anchorCells;
            }

            draw(scrollY = 0, buffer = null) {
                let target = buffer || window;
                let adjustedY = this.isPalette ? this.pos[1] - scrollY : this.pos[1];
                // Draw cells
                for (let [dx, dy] of this.shape) {
                    target.fill(this.color);
                    target.stroke(0);
                    target.strokeWeight(1);
                    target.rect(this.pos[0] + dx * CELL_SIZE, adjustedY + dy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                // Draw border
                let shapeSet = new Set(this.shape.map(([dx, dy]) => `${dx},${dy}`));
                for (let [dx, dy] of this.shape) {
                    let x = this.pos[0] + dx * CELL_SIZE;
                    let y = adjustedY + dy * CELL_SIZE;
                    target.stroke(BLACK);
                    target.strokeWeight(2);
                    if (!shapeSet.has(`${dx},${dy - 1}`)) {
                        target.line(x, y, x + CELL_SIZE, y);
                    }
                    if (!shapeSet.has(`${dx},${dy + 1}`)) {
                        target.line(x, y + CELL_SIZE, x + CELL_SIZE, y + CELL_SIZE);
                    }
                    if (!shapeSet.has(`${dx - 1},${dy}`)) {
                        target.line(x, y, x, y + CELL_SIZE);
                    }
                    if (!shapeSet.has(`${dx + 1},${dy}`)) {
                        target.line(x + CELL_SIZE, y, x + CELL_SIZE, y + CELL_SIZE);
                    }
                }
                // Draw name
                if (this.anchorCells.length > 0) {
                    let minX = Math.min(...this.anchorCells.map(([dx, dy]) => dx));
                    let maxX = Math.max(...this.anchorCells.map(([dx, dy]) => dx));
                    let minY = Math.min(...this.anchorCells.map(([dx, dy]) => dy));
                    let maxY = Math.max(...this.anchorCells.map(([dx, dy]) => dy));
                    let anchorX = this.pos[0] + (minX + maxX) * CELL_SIZE / 2;
                    let anchorY = adjustedY + (minY + maxY) * CELL_SIZE / 2;
                    target.fill(WHITE);
                    target.noStroke();
                    target.textAlign(CENTER, CENTER);
                    target.textSize(16);
                    target.text(this.name, anchorX + CELL_SIZE / 2, anchorY + CELL_SIZE / 2);
                }
            }

            checkClick(mx, my, scrollY = 0) {
                let adjustedY = this.isPalette ? this.pos[1] - scrollY : this.pos[1];
                for (let [dx, dy] of this.shape) {
                    let rectX = this.pos[0] + dx * CELL_SIZE;
                    let rectY = adjustedY + dy * CELL_SIZE;
                    if (mx >= rectX && mx < rectX + CELL_SIZE && my >= rectY && my < rectY + CELL_SIZE) {
                        if (this.isPalette && (rectY < PALETTE_Y || rectY > PALETTE_Y + PALETTE_HEIGHT - CELL_SIZE)) {
                            return false;
                        }
                        return true;
                    }
                }
                return false;
            }

            startDrag(mx, my) {
                this.dragging = true;
                this.prevPos = [...this.pos];
                for (let [dx, dy] of this.shape) {
                    let rectX = this.pos[0] + dx * CELL_SIZE;
                    let rectY = this.pos[1] + dy * CELL_SIZE;
                    if (mx >= rectX && mx < rectX + CELL_SIZE && my >= rectY && my < rectY + CELL_SIZE) {
                        this.offset = [mx - rectX, my - rectY];
                        break;
                    }
                }
                if (this.placed) {
                    let cellX = Math.floor((this.pos[0] - GRID_X) / CELL_SIZE);
                    let cellY = Math.floor((this.pos[1] - GRID_Y) / CELL_SIZE);
                    this.clearCells(cellX, cellY);
                    this.placed = false;
                }
            }

            drag(mx, my) {
                if (this.dragging) {
                    this.pos[0] = mx - this.offset[0];
                    this.pos[1] = my - this.offset[1];
                }
            }

            stopDrag() {
                this.dragging = false;
                let candidateX = Math.floor((this.pos[0] - GRID_X + CELL_SIZE / 2) / CELL_SIZE);
                let candidateY = Math.floor((this.pos[1] - GRID_Y + CELL_SIZE / 2) / CELL_SIZE);
                if (this.canPlace(candidateX, candidateY)) {
                    this.pos[0] = GRID_X + candidateX * CELL_SIZE;
                    this.pos[1] = GRID_Y + candidateY * CELL_SIZE;
                    this.setCells(candidateX, candidateY);
                    this.placed = true;
                } else {
                    this.pos = [...this.prevPos];
                    if (this.placed) {
                        let prevX = Math.floor((this.prevPos[0] - GRID_X) / CELL_SIZE);
                        let prevY = Math.floor((this.prevPos[1] - GRID_Y) / CELL_SIZE);
                        this.setCells(prevX, prevY);
                        this.placed = true;
                    }
                }
            }

            canPlace(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE || grid[gy][gx] !== 0) {
                        return false;
                    }
                }
                return true;
            }

            setCells(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    grid[gy][gx] = 1;
                }
            }

            clearCells(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                        grid[gy][gx] = 0;
                    }
                }
            }

            getHeight() {
                if (!this.shape.length) return 0;
                let minY = Math.min(...this.shape.map(([dx, dy]) => dy));
                let maxY = Math.max(...this.shape.map(([dx, dy]) => dy));
                return (maxY - minY + 1) * CELL_SIZE;
            }
        }

        // Palette blocks
        const paletteBlocks = [
            new Block([[0,0], [1,0], [2,0], [0,1]], RED, [50, 0], "衝鋒槍", [[1,0]], true),
            new Block([[0,0], [1,0], [2,0], [0,1]], RED, [50, 0], "霰彈槍", [[1,0]], true),
            new Block([[0,0], [1,0], [2,0], [3,0], [1,1]], RED, [50, 0], "突擊步槍", [[1,0], [2,0]], true),
            new Block([[0,0], [1,0], [0,1]], RED, [50, 0], "手槍", [[0,0], [1,0]], true),
            new Block([[0,0], [0,1], [0,2], [0,3], [1,3]], RED, [50, 0], "狙擊步槍", [[0,3], [1,3]], true),
            new Block([[1,0], [1,1], [1,2], [1,3], [0,2]], RED, [50, 0], "火焰嘖射器", [[1,2], [0,2]], true),
            new Block([[0,1], [1,1], [2,1], [3,1], [3,0]], RED, [50, 0], "雷射炮", [[1,1], [2,1]], true),
            new Block([[0,0], [0,1], [1,0], [1,1]], RED, [50, 0], "手榴彈", [[0,0], [0,1], [1,0], [1,1]], true),
            new Block([[0,0], [0,1]], PURPLE, [50, 0], "勳章", [[0,0], [0,1]], true),
            new Block([[0,0]], PURPLE, [50, 0], "金幣", [[0,0]], true),
            new Block([[0,0], [1,0], [0,1]], PURPLE, [50, 0], "槍托", [[0,0], [1,0]], true),
            new Block([[0,0], [1,0], [2,0]], PURPLE, [50, 0], "尖刺路障", [[0,0], [1,0], [2,0]], true),
            new Block([[0,0], [0,1], [1,0], [1,1]], PURPLE, [50, 0], "工具組", [[0,0], [0,1], [1,0], [1,1]], true),
            new Block([[0,0], [0,1], [0,2]], PURPLE, [50, 0], "消音器", [[0,0], [0,1], [0,2]], true),
            new Block([[0,0], [1,0], [2,0]], PURPLE, [50, 0], "瞄準鏡", [[0,0], [1,0], [2,0]], true),
            new Block([[0,0], [0,1], [0,2]], PURPLE, [50, 0], "興奮劑", [[0,0], [0,1], [0,2]], true)
        ];

        // Block definitions for import validation
        const blockDefinitions = {};
        paletteBlocks.forEach(block => {
            blockDefinitions[block.name] = [block.shape, block.color, block.anchorCells];
        });

        // Arrange palette blocks
        let currentY = PALETTE_Y + PALETTE_BLOCK_SPACING;
        paletteBlocks.forEach(block => {
            block.pos[1] = currentY;
            currentY += block.getHeight() + PALETTE_BLOCK_SPACING;
        });

        // Placed blocks
        let placedBlocks = [];

        // Scroll variables
        let paletteScrollY = 0;
        const maxScrollY = Math.max(0, paletteBlocks[paletteBlocks.length - 1].pos[1] + paletteBlocks[paletteBlocks.length - 1].getHeight() + PALETTE_BLOCK_SPACING - PALETTE_HEIGHT);

        // Popup
        let popup = null;

        // Graphics buffer for palette
        let paletteBuffer;

        // p5.js setup
        function setup() {
            createCanvas(SCREEN_WIDTH, SCREEN_HEIGHT);
            textFont('Microsoft JhengHei');
            // Create graphics buffer for palette
            paletteBuffer = createGraphics(PALETTE_WIDTH, PALETTE_HEIGHT);
            // Button event listeners
            document.getElementById('importButton').addEventListener('click', importBlocks);
            document.getElementById('exportButton').addEventListener('click', exportBlocks);
        }

        // p5.js draw
        function draw() {
            background(DARK_BG);
            drawGrid();
            drawPalette();
            drawCountPanel();
            textSize(16);
            fill(WHITE);
            textAlign(LEFT, BOTTOM);
            text(versionNumber, 10, SCREEN_HEIGHT - 10);
            placedBlocks.forEach(block => block.draw());
            if (popup) {
                if (Date.now() - popup.startTime > popup.duration) {
                    popup = null;
                } else {
                    let popupElement = document.querySelector('.popup');
                    if (!popupElement) {
                        popupElement = document.createElement('div');
                        popupElement.className = 'popup';
                        popupElement.innerText = popup.message;
                        document.body.appendChild(popupElement);
                    }
                }
            } else {
                let popupElement = document.querySelector('.popup');
                if (popupElement) popupElement.remove();
            }
        }

        function drawGrid() {
            stroke(DARK_GRAY);
            strokeWeight(1);
            for (let i = 0; i <= GRID_SIZE; i++) {
                line(GRID_X, GRID_Y + i * CELL_SIZE, GRID_X + GRID_SIZE * CELL_SIZE, GRID_Y + i * CELL_SIZE);
                line(GRID_X + i * CELL_SIZE, GRID_Y, GRID_X + i * CELL_SIZE, GRID_Y + GRID_SIZE * CELL_SIZE);
            }
        }

        function drawPalette() {
            // Draw palette background
            fill(DARK_GRAY);
            stroke(LIGHT_GRAY);
            strokeWeight(2);
            rect(PALETTE_X, PALETTE_Y, PALETTE_WIDTH, PALETTE_HEIGHT);
            // Draw blocks to buffer
            paletteBuffer.clear();
            paletteBuffer.background(0, 0, 0, 0); // Transparent background
            paletteBlocks.forEach(block => {
                let originalY = block.pos[1];
                block.pos[1] -= paletteScrollY;
                if (block.pos[1] + block.getHeight() >= PALETTE_Y && block.pos[1] <= PALETTE_Y + PALETTE_HEIGHT) {
                    block.draw(0, paletteBuffer);
                }
                block.pos[1] = originalY;
            });
            // Draw buffer to canvas at correct position
            image(paletteBuffer, PALETTE_X, PALETTE_Y);
        }

        function drawCountPanel() {
            fill(DARK_GRAY);
            stroke(LIGHT_GRAY);
            strokeWeight(2);
            rect(COUNT_X, COUNT_Y, COUNT_WIDTH, COUNT_HEIGHT);
            let blockCounts = {};
            placedBlocks.forEach(block => {
                if (block.placed) {
                    blockCounts[block.name] = (blockCounts[block.name] || 0) + 1;
                }
            });
            let y = COUNT_Y + 20;
            textAlign(LEFT, TOP);
            textSize(16);
            fill(WHITE);
            noStroke();
            for (let name in blockCounts) {
                text(`${name} x ${blockCounts[name]}`, COUNT_X + 10, y);
                y += COUNT_TEXT_SPACING;
            }
        }

        function exportBlocks() {
            let data = placedBlocks.filter(block => block.placed).map(block => ({
                name: block.name,
                grid_x: Math.floor((block.pos[0] - GRID_X) / CELL_SIZE),
                grid_y: Math.floor((block.pos[1] - GRID_Y) / CELL_SIZE)
            }));
            let jsonStr = JSON.stringify(data);
            let encoded = btoa(unescape(encodeURIComponent(jsonStr)));
            navigator.clipboard.writeText(encoded).ទ

            .then(() => {
                popup = { message: "Exported to clipboard!", startTime: Date.now(), duration: 2000 };
            });
        }

        function importBlocks() {
            navigator.clipboard.readText().then(encoded => {
                try {
                    let jsonStr = decodeURIComponent(escape(atob(encoded)));
                    let data = JSON.parse(jsonStr);
                    grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
                    placedBlocks = [];
                    data.forEach(blockData => {
                        let name = blockData.name;
                        let gridX = blockData.grid_x;
                        let gridY = blockData.grid_y;
                        if (blockDefinitions[name]) {
                            let [shape, color, anchorCells] = blockDefinitions[name];
                            let block = new Block(shape, color, [GRID_X + gridX * CELL_SIZE, GRID_Y + gridY * CELL_SIZE], name, anchorCells, false);
                            if (block.canPlace(gridX, gridY)) {
                                block.placed = true;
                                block.setCells(gridX, gridY);
                                placedBlocks.push(block);
                            }
                        }
                    });
                    popup = { message: "Imported!", startTime: Date.now(), duration: 2000 };
                } catch (e) {
                    popup = { message: "Import fail!", startTime: Date.now(), duration: 2000 };
                }
            });
        }

        let currentDragging = null;

        function mousePressed() {
            if (mouseX >= 480 && mouseX <= 580 && mouseY >= 545 && mouseY <= 585) return;
            if (mouseX >= 600 && mouseX <= 700 && mouseY >= 545 && mouseY <= 585) return;
            for (let block of [...placedBlocks].reverse()) {
                if (block.checkClick(mouseX, mouseY)) {
                    currentDragging = block;
                    block.startDrag(mouseX, mouseY);
                    return;
                }
            }
            for (let block of [...paletteBlocks].reverse()) {
                if (block.checkClick(mouseX, mouseY, paletteScrollY)) {
                    let newBlock = new Block(block.shape, block.color, [block.pos[0], block.pos[1] - paletteScrollY], block.name, block.anchorCells, false);
                    placedBlocks.push(newBlock);
                    currentDragging = newBlock;
                    newBlock.startDrag(mouseX, mouseY);
                    return;
                }
            }
        }

        function mouseDragged() {
            if (currentDragging) {
                currentDragging.drag(mouseX, mouseY);
            }
        }

        function mouseReleased() {
            if (currentDragging) {
                currentDragging.stopDrag();
                if (!currentDragging.placed) {
                    placedBlocks = placedBlocks.filter(block => block !== currentDragging);
                }
                currentDragging = null;
            }
        }

        function mouseWheel(event) {
            if (mouseX >= PALETTE_X && mouseX <= PALETTE_X + PALETTE_WIDTH && mouseY >= PALETTE_Y && mouseY <= PALETTE_Y + PALETTE_HEIGHT) {
                paletteScrollY += event.delta * PALETTE_SCROLL_SPEED / 100;
                paletteScrollY = constrain(paletteScrollY, 0, maxScrollY);
            }
        }
    </script>
</body>
</html>
