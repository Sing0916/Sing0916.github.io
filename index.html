<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Salvation Breakers Helper</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <link rel="icon" href="doro.ico" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            background-color: rgb(20, 20, 20);
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            color: white;
        }
        canvas {
            display: block;
        }
        .button-container {
            position: absolute;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10; /* Ensure buttons are above canvas */
        }
        button {
            background-color: rgb(50, 50, 50);
            color: white;
            border: 2px solid rgb(180, 180, 180);
            padding: 10px;
            cursor: pointer;
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            font-size: 16px;
            z-index: 5;
            flex: 1;
            margin: 0 5px;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        button:hover {
            background-color: rgb(180, 180, 180);
        }
        .popup {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border: 2px solid rgb(180, 180, 180);
            border-radius: 5px;
            font-size: 16px;
            bottom: 10px;
            right: 10px;
            z-index: 10;
        }
        .toggleGridEditButton {
            background-color: rgb(0, 128, 0);
        }
    </style>
</head>
<body>
    <div id="buttonContainer" class="button-container">
        <button id="importButton">Import</button>
        <button id="exportButton">Export</button>
        <button id="toggleGridEditButton" class="toggleGridEditButton">Grid Edit: Off</button>
    </div>
    <script>
        // Version number
        const versionNumber = "v1.8";

        // Grid settings
        const GRID_SIZE = 9;

        // Palette settings
        const PALETTE_SCROLL_SPEED = 50;
        const PALETTE_BLOCK_SPACING = 10;

        // Count panel settings
        const COUNT_TEXT_SPACING = 30;

        // Colors
        const DARK_BG = [20, 20, 20];
        const LIGHT_GRAY = [180, 180, 180];
        const DARK_GRAY = [50, 50, 50];
        const WHITE = [255, 255, 255];
        const BLACK = [0, 0, 0];
        const RED = [200, 0, 0];
        const PURPLE = [128, 0, 128];

        // Grid occupation (0: empty, 1: occupied, -1: disabled)
        let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));

        // Grid edit mode
        let gridEditMode = false;

        // Block class
        class Block {
            constructor(shape, color, pos, name, anchorCells, isPalette = false) {
                this.shape = shape;
                this.color = color;
                this.pos = [...pos];
                this.prevPos = [...pos];
                this.placed = false;
                this.dragging = false;
                this.offset = [0, 0];
                this.isPalette = isPalette;
                this.name = name;
                this.anchorCells = anchorCells;
            }

            draw(scrollY = 0, buffer = null) {
                let target = buffer || window;
                let adjustedY = this.isPalette ? this.pos[1] - scrollY : this.pos[1];
                // Draw cells without individual borders
                target.noStroke();
                target.fill(this.color);
                for (let [dx, dy] of this.shape) {
                    target.rect(this.pos[0] + dx * CELL_SIZE, adjustedY + dy * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
                // Draw outer border for the whole block
                let shapeSet = new Set(this.shape.map(([dx, dy]) => `${dx},${dy}`));
                for (let [dx, dy] of this.shape) {
                    let x = this.pos[0] + dx * CELL_SIZE;
                    let y = adjustedY + dy * CELL_SIZE;
                    target.stroke(BLACK);
                    target.strokeWeight(2);
                    if (!shapeSet.has(`${dx},${dy - 1}`)) {
                        target.line(x, y, x + CELL_SIZE, y);
                    }
                    if (!shapeSet.has(`${dx},${dy + 1}`)) {
                        target.line(x, y + CELL_SIZE, x + CELL_SIZE, y + CELL_SIZE);
                    }
                    if (!shapeSet.has(`${dx - 1},${dy}`)) {
                        target.line(x, y, x, y + CELL_SIZE);
                    }
                    if (!shapeSet.has(`${dx + 1},${dy}`)) {
                        target.line(x + CELL_SIZE, y, x + CELL_SIZE, y + CELL_SIZE);
                    }
                }
                // Draw name
                if (this.anchorCells.length > 0) {
                    let minX = Math.min(...this.anchorCells.map(([dx, dy]) => dx));
                    let maxX = Math.max(...this.anchorCells.map(([dx, dy]) => dx));
                    let minY = Math.min(...this.anchorCells.map(([dx, dy]) => dy));
                    let maxY = Math.max(...this.anchorCells.map(([dx, dy]) => dy));
                    let anchorX = this.pos[0] + (minX + maxX) * CELL_SIZE / 2;
                    let anchorY = adjustedY + (minY + maxY) * CELL_SIZE / 2;
                    target.fill(WHITE);
                    target.noStroke();
                    target.textAlign(CENTER, CENTER);
                    target.textSize(16);
                    target.text(this.name, anchorX + CELL_SIZE / 2, anchorY + CELL_SIZE / 2);
                }
            }

            checkClick(mx, my, scrollY = 0) {
                let adjustedX = this.isPalette ? PALETTE_X + this.pos[0] : this.pos[0];
                let adjustedY = this.isPalette ? PALETTE_Y + this.pos[1] - scrollY : this.pos[1];
                for (let [dx, dy] of this.shape) {
                    let rectX = adjustedX + dx * CELL_SIZE;
                    let rectY = adjustedY + dy * CELL_SIZE;
                    if (mx >= rectX && mx < rectX + CELL_SIZE && my >= rectY && my < rectY + CELL_SIZE) {
                        if (this.isPalette && (rectY < PALETTE_Y || rectY > PALETTE_Y + PALETTE_HEIGHT - CELL_SIZE || rectX < PALETTE_X || rectX > PALETTE_X + PALETTE_WIDTH - CELL_SIZE)) {
                            return false;
                        }
                        return true;
                    }
                }
                return false;
            }

            startDrag(mx, my) {
                this.dragging = true;
                this.prevPos = [...this.pos];
                for (let [dx, dy] of this.shape) {
                    let rectX = this.pos[0] + dx * CELL_SIZE;
                    let rectY = this.pos[1] + dy * CELL_SIZE;
                    if (mx >= rectX && mx < rectX + CELL_SIZE && my >= rectY && my < rectY + CELL_SIZE) {
                        this.offset = [mx - rectX, my - rectY];
                        break;
                    }
                }
                if (this.placed) {
                    let cellX = Math.floor((this.pos[0] - GRID_X) / CELL_SIZE);
                    let cellY = Math.floor((this.pos[1] - GRID_Y) / CELL_SIZE);
                    this.clearCells(cellX, cellY);
                    this.placed = false;
                }
            }

            drag(mx, my) {
                if (this.dragging) {
                    this.pos[0] = mx - this.offset[0];
                    this.pos[1] = my - this.offset[1];
                }
            }

            stopDrag() {
                this.dragging = false;
                let candidateX = Math.floor((this.pos[0] - GRID_X + CELL_SIZE / 2) / CELL_SIZE);
                let candidateY = Math.floor((this.pos[1] - GRID_Y + CELL_SIZE / 2) / CELL_SIZE);
                if (this.canPlace(candidateX, candidateY)) {
                    this.pos[0] = GRID_X + candidateX * CELL_SIZE;
                    this.pos[1] = GRID_Y + candidateY * CELL_SIZE;
                    this.setCells(candidateX, candidateY);
                    this.placed = true;
                } else {
                    // Check if failure is due to occupied cells (grid value 1)
                    let canPlaceAfterClearing = true;
                    let cellsToClear = [];
                    for (let [dx, dy] of this.shape) {
                        let gx = candidateX + dx;
                        let gy = candidateY + dy;
                        if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE || grid[gy][gx] === -1) {
                            canPlaceAfterClearing = false;
                            break;
                        }
                        if (grid[gy][gx] === 1) {
                            cellsToClear.push([gx, gy]);
                        }
                    }
                    if (canPlaceAfterClearing) {
                        // Remove blocks occupying the cells
                        placedBlocks = placedBlocks.filter(block => {
                            if (block === this || !block.placed) return true;
                            let blockX = Math.floor((block.pos[0] - GRID_X) / CELL_SIZE);
                            let blockY = Math.floor((block.pos[1] - GRID_Y) / CELL_SIZE);
                            for (let [gx, gy] of cellsToClear) {
                                for (let [dx, dy] of block.shape) {
                                    if (blockX + dx === gx && blockY + dy === gy) {
                                        block.clearCells(blockX, blockY);
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                        // Place the block
                        this.pos[0] = GRID_X + candidateX * CELL_SIZE;
                        this.pos[1] = GRID_Y + candidateY * CELL_SIZE;
                        this.setCells(candidateX, candidateY);
                        this.placed = true;
                    } else {
                        // Revert to previous position
                        this.pos = [...this.prevPos];
                        if (this.placed) {
                            let prevX = Math.floor((this.prevPos[0] - GRID_X) / CELL_SIZE);
                            let prevY = Math.floor((this.prevPos[1] - GRID_Y) / CELL_SIZE);
                            this.setCells(prevX, prevY);
                            this.placed = true;
                        }
                    }
                }
            }

            canPlace(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE || grid[gy][gx] !== 0) {
                        return false;
                    }
                }
                return true;
            }

            setCells(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    grid[gy][gx] = 1;
                }
            }

            clearCells(cellX, cellY) {
                for (let [dx, dy] of this.shape) {
                    let gx = cellX + dx;
                    let gy = cellY + dy;
                    if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                        grid[gy][gx] = 0;
                    }
                }
            }

            getHeight() {
                if (!this.shape.length) return 0;
                let minY = Math.min(...this.shape.map(([dx, dy]) => dy));
                let maxY = Math.max(...this.shape.map(([dx, dy]) => dy));
                return (maxY - minY + 1) * CELL_SIZE;
            }

            getWidth() {
                if (!this.shape.length) return 0;
                let minX = Math.min(...this.shape.map(([dx, dy]) => dx));
                let maxX = Math.max(...this.shape.map(([dx, dy]) => dx));
                return (maxX - minX + 1) * CELL_SIZE;
            }
        }

        // Palette blocks
        const paletteBlocks = [
            new Block([[0,0], [1,0], [2,0], [0,1]], RED, [0, 0], "衝鋒槍", [[1,0]], true),
            new Block([[0,0], [1,0], [2,0], [0,1]], RED, [0, 0], "霰彈槍", [[1,0]], true),
            new Block([[0,0], [1,0], [2,0], [3,0], [1,1]], RED, [0, 0], "突擊步槍", [[1,0], [2,0]], true),
            new Block([[0,0], [1,0], [0,1]], RED, [0, 0], "手槍", [[0,0], [1,0]], true),
            new Block([[0,0], [0,1], [0,2], [0,3], [1,3]], RED, [0, 0], "狙擊步槍", [[0,3], [1,3]], true),
            new Block([[1,0], [1,1], [1,2], [1,3], [0,2]], RED, [0, 0], "火焰嘖射器", [[1,2], [0,2]], true),
            new Block([[0,1], [1,1], [2,1], [3,1], [3,0]], RED, [0, 0], "雷射炮", [[1,1], [2,1]], true),
            new Block([[0,0], [0,1], [1,0], [1,1]], RED, [0, 0], "手榴彈", [[0,0], [0,1], [1,0], [1,1]], true),
            new Block([[0,0], [0,1]], PURPLE, [0, 0], "勳章", [[0,0], [0,1]], true),
            new Block([[0,0]], PURPLE, [0, 0], "金幣", [[0,0]], true),
            new Block([[0,0], [1,0], [0,1]], PURPLE, [0, 0], "槍托", [[0,0], [1,0]], true),
            new Block([[0,0], [1,0], [2,0]], PURPLE, [0, 0], "尖刺路障", [[0,0], [1,0], [2,0]], true),
            new Block([[0,0], [0,1], [1,0], [1,1]], PURPLE, [0, 0], "工具組", [[0,0], [0,1], [1,0], [1,1]], true),
            new Block([[0,0], [0,1], [0,2]], PURPLE, [0, 0], "消音器", [[0,0], [0,1], [0,2]], true),
            new Block([[0,0], [1,0], [2,0]], PURPLE, [0, 0], "瞄準鏡", [[0,0], [1,0], [2,0]], true),
            new Block([[0,0], [0,1], [0,2]], PURPLE, [0, 0], "興奮劑", [[0,0], [0,1], [0,2]], true)
        ];

        // Block definitions for import validation
        const blockDefinitions = {};
        paletteBlocks.forEach(block => {
            blockDefinitions[block.name] = [block.shape, block.color, block.anchorCells];
        });

        // Placed blocks
        let placedBlocks = [];

        // Scroll variables
        let paletteScrollY = 0;
        let maxScrollY;
        let countScrollY = 0;
        let maxCountScrollY = 0;

        // Popup
        let popup = null;

        // Graphics buffer for palette and count
        let paletteBuffer;
        let countBuffer;

        // Layout variables
        let SCREEN_WIDTH;
        let SCREEN_HEIGHT;
        let CELL_SIZE;
        let GRID_X;
        let GRID_Y;
        let PALETTE_X;
        let PALETTE_Y;
        let PALETTE_WIDTH;
        let PALETTE_HEIGHT;
        let COUNT_X;
        let COUNT_Y;
        let COUNT_WIDTH;
        let COUNT_HEIGHT;
        let isMobile;

        // Touch tracking
        let currentDragging = null;
        let prevTouchY = null; // Track previous touch Y position for scrolling
        let isScrollingPalette = false; // Flag to track if scrolling palette
        let isScrollingCount = false; // Flag to track if scrolling count panel

        function setLayout() {
            isMobile = window.innerWidth < 768;
            SCREEN_WIDTH = isMobile ? window.innerWidth : 980;
            if (isMobile) {
                CELL_SIZE = Math.floor(SCREEN_WIDTH * 0.7 / GRID_SIZE);
                let gridWidth = CELL_SIZE * GRID_SIZE;
                let currentY = 10;
                COUNT_X = 10;
                COUNT_Y = currentY;
                COUNT_WIDTH = SCREEN_WIDTH - 20;
                COUNT_HEIGHT = 100;
                currentY += COUNT_HEIGHT + 20;
                GRID_X = (SCREEN_WIDTH - gridWidth) / 2;
                GRID_Y = currentY;
                currentY += gridWidth + 20;
                // Position button container
                let buttonContainer = document.getElementById('buttonContainer');
                buttonContainer.style.left = '10px';
                buttonContainer.style.top = currentY + 'px';
                buttonContainer.style.width = (SCREEN_WIDTH - 20) + 'px';
                buttonContainer.style.height = '40px';
                currentY += 60;
                PALETTE_X = 10;
                PALETTE_Y = currentY;
                PALETTE_WIDTH = SCREEN_WIDTH - 20;
                PALETTE_HEIGHT = 200;
                currentY += PALETTE_HEIGHT + 20;
                SCREEN_HEIGHT = currentY;
            } else {
                CELL_SIZE = 50;
                SCREEN_HEIGHT = 650;
                GRID_X = 300;
                GRID_Y = 75;
                PALETTE_X = 10;
                PALETTE_Y = 10;
                PALETTE_WIDTH = 270;
                PALETTE_HEIGHT = SCREEN_HEIGHT - 70;
                COUNT_X = GRID_X + GRID_SIZE * CELL_SIZE + 20;
                COUNT_Y = 10;
                COUNT_WIDTH = 200;
                COUNT_HEIGHT = SCREEN_HEIGHT - 70;
                // Position button container
                let buttonContainer = document.getElementById('buttonContainer');
                buttonContainer.style.left = GRID_X + 'px';
                buttonContainer.style.top = (GRID_Y + GRID_SIZE * CELL_SIZE + 20) + 'px';
                buttonContainer.style.width = (GRID_SIZE * CELL_SIZE) + 'px';
                buttonContainer.style.height = '40px';
            }

            // Arrange palette blocks (relative positions)
            let paletteCurrentY = PALETTE_BLOCK_SPACING;
            paletteBlocks.forEach(block => {
                block.pos[1] = paletteCurrentY;
                paletteCurrentY += block.getHeight() + PALETTE_BLOCK_SPACING;
            });

            // Center palette blocks horizontally
            paletteBlocks.forEach(block => {
                block.pos[0] = (PALETTE_WIDTH - block.getWidth()) / 2;
            });

            // Update maxScrollY
            maxScrollY = Math.max(0, paletteBlocks[paletteBlocks.length - 1].pos[1] + paletteBlocks[paletteBlocks.length - 1].getHeight() + PALETTE_BLOCK_SPACING - PALETTE_HEIGHT);
        }

        // Initial layout
        setLayout();

        // p5.js setup
        function setup() {
            createCanvas(SCREEN_WIDTH, SCREEN_HEIGHT);
            textFont('Microsoft JhengHei');
            // Create graphics buffers
            paletteBuffer = createGraphics(PALETTE_WIDTH, PALETTE_HEIGHT);
            countBuffer = createGraphics(COUNT_WIDTH, COUNT_HEIGHT);
            // Button event listeners
            let importButton = document.getElementById('importButton');
            importButton.addEventListener('click', importBlocks);
            importButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                importBlocks();
            });

            let exportButton = document.getElementById('exportButton');
            exportButton.addEventListener('click', exportBlocks);
            exportButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                exportBlocks();
            });

            let toggleButton = document.getElementById('toggleGridEditButton');
            toggleButton.addEventListener('click', toggleGridEditMode);
            toggleButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleGridEditMode();
            });

            // Prevent page scrolling during block drag or panel scrolling on mobile
            document.addEventListener('touchmove', preventScrollDuringDrag, { passive: false });

            // Add resize listener
            window.addEventListener('resize', () => {
                let old_GRID_X = GRID_X;
                let old_GRID_Y = GRID_Y;
                let old_CELL_SIZE = CELL_SIZE;
                setLayout();
                resizeCanvas(SCREEN_WIDTH, SCREEN_HEIGHT);
                paletteBuffer = createGraphics(PALETTE_WIDTH, PALETTE_HEIGHT);
                countBuffer = createGraphics(COUNT_WIDTH, COUNT_HEIGHT);
                // Update placed blocks positions
                placedBlocks.forEach(block => {
                    if (block.placed) {
                        let cellX = Math.floor((block.pos[0] - old_GRID_X) / old_CELL_SIZE);
                        let cellY = Math.floor((block.pos[1] - old_GRID_Y) / old_CELL_SIZE);
                        block.pos[0] = GRID_X + cellX * CELL_SIZE;
                        block.pos[1] = GRID_Y + cellY * CELL_SIZE;
                    }
                });
            });
        }

        function preventScrollDuringDrag(e) {
            if (isMobile) {
                let touchX = e.touches[0]?.clientX;
                let touchY = e.touches[0]?.clientY;
                // Check if touch is over any button
                let buttons = ['importButton', 'exportButton', 'toggleGridEditButton'];
                for (let buttonId of buttons) {
                    let button = document.getElementById(buttonId);
                    let rect = button.getBoundingClientRect();
                    if (
                        touchX >= rect.left &&
                        touchX <= rect.right &&
                        touchY >= rect.top &&
                        touchY <= rect.bottom
                    ) {
                        return; // Do not prevent default for button touches
                    }
                }
                if (
                    currentDragging ||
                    (gridEditMode &&
                        touchX >= GRID_X &&
                        touchX < GRID_X + GRID_SIZE * CELL_SIZE &&
                        touchY >= GRID_Y &&
                        touchY < GRID_Y + GRID_SIZE * CELL_SIZE) ||
                    isScrollingPalette ||
                    isScrollingCount
                ) {
                    e.preventDefault();
                }
            }
        }

        function toggleGridEditMode() {
            gridEditMode = !gridEditMode;
            document.getElementById('toggleGridEditButton').innerText = `Grid Edit: ${gridEditMode ? 'On' : 'Off'}`;
            document.getElementById('toggleGridEditButton').style.background = gridEditMode ? 'red' : 'rgb(0, 128, 0)';
        }

        // p5.js draw
        function draw() {
            background(DARK_BG);
            drawGrid();
            drawPalette();
            drawCountPanel();
            textSize(16);
            fill(WHITE);
            textAlign(LEFT, BOTTOM);
            text(versionNumber, 10, SCREEN_HEIGHT - 10);
            placedBlocks.forEach(block => block.draw());
            if (popup) {
                if (Date.now() - popup.startTime > popup.duration) {
                    popup = null;
                } else {
                    let popupElement = document.querySelector('.popup');
                    if (!popupElement) {
                        popupElement = document.createElement('div');
                        popupElement.className = 'popup';
                        popupElement.innerText = popup.message;
                        document.body.appendChild(popupElement);
                    }
                }
            } else {
                let popupElement = document.querySelector('.popup');
                if (popupElement) popupElement.remove();
            }
        }

        function drawGrid() {
            stroke(DARK_GRAY);
            strokeWeight(1);
            for (let i = 0; i <= GRID_SIZE; i++) {
                line(GRID_X, GRID_Y + i * CELL_SIZE, GRID_X + GRID_SIZE * CELL_SIZE, GRID_Y + i * CELL_SIZE);
                line(GRID_X + i * CELL_SIZE, GRID_Y, GRID_X + i * CELL_SIZE, GRID_Y + GRID_SIZE * CELL_SIZE);
            }
            // Draw red crosses for disabled cells
            stroke(RED);
            strokeWeight(2);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === -1) {
                        let cellX = GRID_X + x * CELL_SIZE;
                        let cellY = GRID_Y + y * CELL_SIZE;
                        line(cellX, cellY, cellX + CELL_SIZE, cellY + CELL_SIZE);
                        line(cellX + CELL_SIZE, cellY, cellX, cellY + CELL_SIZE);
                    }
                }
            }
        }

        function drawPalette() {
            // Draw palette background
            fill(DARK_GRAY);
            stroke(LIGHT_GRAY);
            strokeWeight(2);
            rect(PALETTE_X, PALETTE_Y, PALETTE_WIDTH, PALETTE_HEIGHT);
            // Draw blocks to buffer
            paletteBuffer.clear();
            paletteBuffer.background(0, 0, 0, 0); // Transparent background
            paletteBlocks.forEach(block => {
                let top = block.pos[1] - paletteScrollY;
                let bottom = top + block.getHeight();
                if (bottom >= 0 && top < PALETTE_HEIGHT) {
                    block.draw(paletteScrollY, paletteBuffer);
                }
            });
            // Draw buffer to canvas at correct position
            image(paletteBuffer, PALETTE_X, PALETTE_Y);
        }

        function drawCountPanel() {
            // Calculate counts
            let blockCounts = {};
            placedBlocks.forEach(block => {
                if (block.placed) {
                    blockCounts[block.name] = (blockCounts[block.name] || 0) + 1;
                }
            });
            let entries = Object.entries(blockCounts).map(([name, count]) => `${name} x ${count}`);

            let numEntries = entries.length;
            let numColumns = isMobile ? 2 : 1;
            let rows = Math.ceil(numEntries / numColumns);
            let totalContentHeight = rows * COUNT_TEXT_SPACING + 40;
            maxCountScrollY = Math.max(0, totalContentHeight - COUNT_HEIGHT);

            // Draw background
            fill(DARK_GRAY);
            stroke(LIGHT_GRAY);
            strokeWeight(2);
            rect(COUNT_X, COUNT_Y, COUNT_WIDTH, COUNT_HEIGHT);

            // Draw to buffer
            countBuffer.clear();
            countBuffer.background(0, 0, 0, 0); // Transparent background
            countBuffer.textAlign(LEFT, TOP);
            countBuffer.textSize(16);
            countBuffer.fill(WHITE);
            countBuffer.noStroke();

            let y = 20 - countScrollY;
            let index = 0;
            for (let row = 0; row < rows; row++) {
                if (y >= COUNT_HEIGHT || y + COUNT_TEXT_SPACING < 0) {
                    // Skip if row is out of view
                    index += numColumns;
                    y += COUNT_TEXT_SPACING;
                    continue;
                }
                for (let col = 0; col < numColumns; col++) {
                    if (index < numEntries) {
                        let xPos = (COUNT_WIDTH / numColumns) * col + 10;
                        countBuffer.text(entries[index], xPos, y);
                        index++;
                    }
                }
                y += COUNT_TEXT_SPACING;
            }
            // Draw buffer to canvas
            image(countBuffer, COUNT_X, COUNT_Y);
        }

        function exportBlocks() {
            let data = placedBlocks.filter(block => block.placed).map(block => ({
                name: block.name,
                grid_x: Math.floor((block.pos[0] - GRID_X) / CELL_SIZE),
                grid_y: Math.floor((block.pos[1] - GRID_Y) / CELL_SIZE)
            }));
            let jsonStr = JSON.stringify(data);
            let encoded = btoa(unescape(encodeURIComponent(jsonStr)));
            navigator.clipboard.writeText(encoded)
                .then(() => {
                    popup = { message: "Exported to clipboard!", startTime: Date.now(), duration: 2000 };
                });
        }

        function importBlocks() {
            navigator.clipboard.readText().then(encoded => {
                try {
                    let jsonStr = decodeURIComponent(escape(atob(encoded)));
                    let data = JSON.parse(jsonStr);
                    grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
                    placedBlocks = [];
                    data.forEach(blockData => {
                        let name = blockData.name;
                        let gridX = blockData.grid_x;
                        let gridY = blockData.grid_y;
                        if (blockDefinitions[name]) {
                            let [shape, color, anchorCells] = blockDefinitions[name];
                            let block = new Block(shape, color, [GRID_X + gridX * CELL_SIZE, GRID_Y + gridY * CELL_SIZE], name, anchorCells, false);
                            if (block.canPlace(gridX, gridY)) {
                                block.placed = true;
                                block.setCells(gridX, gridY);
                                placedBlocks.push(block);
                            }
                        }
                    });
                    popup = { message: "Imported!", startTime: Date.now(), duration: 2000 };
                } catch (e) {
                    popup = { message: "Import fail!", startTime: Date.now(), duration: 2000 };
                }
            });
        }

        function mousePressed() {
            if (gridEditMode) {
                // Handle grid edit mode click
                let cellX = Math.floor((mouseX - GRID_X) / CELL_SIZE);
                let cellY = Math.floor((mouseY - GRID_Y) / CELL_SIZE);
                if (cellX >= 0 && cellX < GRID_SIZE && cellY >= 0 && cellY < GRID_SIZE) {
                    if (grid[cellY][cellX] === 1) {
                        // Remove block occupying the cell
                        placedBlocks = placedBlocks.filter(block => {
                            if (block.placed) {
                                let blockX = Math.floor((block.pos[0] - GRID_X) / CELL_SIZE);
                                let blockY = Math.floor((block.pos[1] - GRID_Y) / CELL_SIZE);
                                for (let [dx, dy] of block.shape) {
                                    if (blockX + dx === cellX && blockY + dy === cellY) {
                                        block.clearCells(blockX, blockY);
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                        grid[cellY][cellX] = -1; // Disable the cell
                    } else {
                        // Toggle cell state
                        grid[cellY][cellX] = grid[cellY][cellX] === -1 ? 0 : -1;
                    }
                }
                return;
            }

            // Normal block dragging
            for (let block of [...placedBlocks].reverse()) {
                if (block.checkClick(mouseX, mouseY)) {
                    currentDragging = block;
                    block.startDrag(mouseX, mouseY);
                    return;
                }
            }
            for (let block of [...paletteBlocks].reverse()) {
                if (block.checkClick(mouseX, mouseY, paletteScrollY)) {
                    let newX = PALETTE_X + block.pos[0];
                    let newY = PALETTE_Y + block.pos[1] - paletteScrollY;
                    let newBlock = new Block(block.shape, block.color, [newX, newY], block.name, block.anchorCells, false);
                    placedBlocks.push(newBlock);
                    currentDragging = newBlock;
                    newBlock.startDrag(mouseX, mouseY);
                    return;
                }
            }
        }

        function mouseDragged() {
            if (currentDragging) {
                currentDragging.drag(mouseX, mouseY);
            } else {
                // Scroll palette if dragging in palette area
                if (mouseX >= PALETTE_X && mouseX < PALETTE_X + PALETTE_WIDTH && mouseY >= PALETTE_Y && mouseY < PALETTE_Y + PALETTE_HEIGHT) {
                    paletteScrollY -= (mouseY - pmouseY);
                    paletteScrollY = constrain(paletteScrollY, 0, maxScrollY);
                }
                // Scroll count panel if dragging in count area
                if (mouseX >= COUNT_X && mouseX < COUNT_X + COUNT_WIDTH && mouseY >= COUNT_Y && mouseY < COUNT_Y + COUNT_HEIGHT) {
                    countScrollY -= (mouseY - pmouseY);
                    countScrollY = constrain(countScrollY, 0, maxCountScrollY);
                }
            }
        }

        function mouseReleased() {
            if (currentDragging) {
                currentDragging.stopDrag();
                if (!currentDragging.placed) {
                    placedBlocks = placedBlocks.filter(block => block !== currentDragging);
                }
                currentDragging = null;
            }
        }

        function mouseWheel(event) {
            // Scroll palette
            if (mouseX >= PALETTE_X && mouseX <= PALETTE_X + PALETTE_WIDTH && mouseY >= PALETTE_Y && mouseY <= PALETTE_Y + PALETTE_HEIGHT) {
                paletteScrollY += event.delta * PALETTE_SCROLL_SPEED / 100;
                paletteScrollY = constrain(paletteScrollY, 0, maxScrollY);
            }
            // Scroll count panel
            if (mouseX >= COUNT_X && mouseX <= COUNT_X + COUNT_WIDTH && mouseY >= COUNT_Y && mouseY <= COUNT_Y + COUNT_HEIGHT) {
                countScrollY += event.delta * PALETTE_SCROLL_SPEED / 100;
                countScrollY = constrain(countScrollY, 0, maxCountScrollY);
            }
        }

        function touchStarted() {
            let touchX = touches[0] ? touches[0].x : mouseX;
            let touchY = touches[0] ? touches[0].y : mouseY;

            // Initialize previous touch position
            prevTouchY = touchY;

            // Check if touch is over any button
            let buttons = ['importButton', 'exportButton', 'toggleGridEditButton'];
            for (let buttonId of buttons) {
                let button = document.getElementById(buttonId);
                let rect = button.getBoundingClientRect();
                if (
                    touchX >= rect.left &&
                    touchX <= rect.right &&
                    touchY >= rect.top &&
                    touchY <= rect.bottom
                ) {
                    return true; // Let the button handle the event
                }
            }

            if (gridEditMode) {
                // Handle grid edit mode for touch
                let cellX = Math.floor((touchX - GRID_X) / CELL_SIZE);
                let cellY = Math.floor((touchY - GRID_Y) / CELL_SIZE);
                if (cellX >= 0 && cellX < GRID_SIZE && cellY >= 0 && cellY < GRID_SIZE) {
                    if (grid[cellY][cellX] === 1) {
                        // Remove block occupying the cell
                        placedBlocks = placedBlocks.filter(block => {
                            if (block.placed) {
                                let blockX = Math.floor((block.pos[0] - GRID_X) / CELL_SIZE);
                                let blockY = Math.floor((block.pos[1] - GRID_Y) / CELL_SIZE);
                                for (let [dx, dy] of block.shape) {
                                    if (blockX + dx === cellX && blockY + dy === cellY) {
                                        block.clearCells(blockX, blockY);
                                        return false;
                                    }
                                }
                            }
                            return true;
                        });
                        grid[cellY][cellX] = -1; // Disable the cell
                    } else {
                        // Toggle cell state
                        grid[cellY][cellX] = grid[cellY][cellX] === -1 ? 0 : -1;
                    }
                }
                return false; // Prevent default touch behavior
            }

            // Check for palette or count panel scrolling
            isScrollingPalette = touchX >= PALETTE_X && touchX < PALETTE_X + PALETTE_WIDTH && touchY >= PALETTE_Y && touchY < PALETTE_Y + PALETTE_HEIGHT;
            isScrollingCount = touchX >= COUNT_X && touchX < COUNT_X + COUNT_WIDTH && touchY >= COUNT_Y && touchY < COUNT_Y + COUNT_HEIGHT;

            // Normal block dragging for touch
            for (let block of [...placedBlocks].reverse()) {
                if (block.checkClick(touchX, touchY)) {
                    currentDragging = block;
                    block.startDrag(touchX, touchY);
                    isScrollingPalette = false; // Disable scrolling if dragging a block
                    isScrollingCount = false;
                    return false;
                }
            }
            for (let block of [...paletteBlocks].reverse()) {
                if (block.checkClick(touchX, touchY, paletteScrollY)) {
                    let newX = PALETTE_X + block.pos[0];
                    let newY = PALETTE_Y + block.pos[1] - paletteScrollY;
                    let newBlock = new Block(block.shape, block.color, [newX, newY], block.name, block.anchorCells, false);
                    placedBlocks.push(newBlock);
                    currentDragging = newBlock;
                    newBlock.startDrag(touchX, touchY);
                    isScrollingPalette = false; // Disable scrolling if dragging a block
                    isScrollingCount = false;
                    return false;
                }
            }
            return true;
        }

        function touchMoved() {
            let touchX = touches[0] ? touches[0].x : mouseX;
            let touchY = touches[0] ? touches[0].y : mouseY;

            if (currentDragging) {
                currentDragging.drag(touchX, touchY);
                prevTouchY = touchY; // Update previous touch position
                return false; // Prevent default scrolling
            } else if (isScrollingPalette && touches[0]) {
                // Scroll palette
                let deltaY = prevTouchY - touchY; // Calculate delta (reversed for natural scrolling)
                paletteScrollY += deltaY * PALETTE_SCROLL_SPEED / 100;
                paletteScrollY = constrain(paletteScrollY, 0, maxScrollY);
                prevTouchY = touchY; // Update previous touch position
                return false; // Prevent default scrolling
            } else if (isScrollingCount && touches[0]) {
                // Scroll count panel
                let deltaY = prevTouchY - touchY; // Calculate delta (reversed for natural scrolling)
                countScrollY += deltaY * PALETTE_SCROLL_SPEED / 100;
                countScrollY = constrain(countScrollY, 0, maxCountScrollY);
                prevTouchY = touchY; // Update previous touch position
                return false; // Prevent default scrolling
            }
            prevTouchY = touchY; // Update previous touch position
            return true;
        }

        function touchEnded() {
            if (currentDragging) {
                currentDragging.stopDrag();
                if (!currentDragging.placed) {
                    placedBlocks = placedBlocks.filter(block => block !== currentDragging);
                }
                currentDragging = null;
            }
            isScrollingPalette = false; // Reset scrolling flags
            isScrollingCount = false;
            prevTouchY = null; // Reset previous touch position
            return true;
        }
    </script>
</body>
</html>
